(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{323:function(r,a,e){"use strict";e.r(a);var s=e(7),t=Object(s.a)({},(function(){var r=this,a=r._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"kafka"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[r._v("#")]),r._v(" Kafka")]),r._v(" "),a("p",[r._v("Kafka 最初由Linkedin公司开发，是一个分布式的、支持分区的（partition）、多副本的（replica）、基于zookeeper协调消息处理系统。")]),r._v(" "),a("h3",{attrs:{id:"kafka特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka特性"}},[r._v("#")]),r._v(" Kafka特性")]),r._v(" "),a("ol",[a("li",[r._v("高吞吐、低延迟：每秒可以处理几十万条消息")])]),r._v(" "),a("h2",{attrs:{id:"架构图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构图"}},[r._v("#")]),r._v(" 架构图")]),r._v(" "),a("p",[a("img",{attrs:{src:"/images/middleware/kafka/Kafka%E6%9E%B6%E6%9E%84%E5%9B%BE.png",alt:"Kafka架构图"}})]),r._v(" "),a("h2",{attrs:{id:"常见问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[r._v("#")]),r._v(" 常见问题")]),r._v(" "),a("h3",{attrs:{id:"kafka如何保证消息不重复消费"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka如何保证消息不重复消费"}},[r._v("#")]),r._v(" kafka如何保证消息不重复消费")]),r._v(" "),a("p",[a("em",[r._v("重复消费的场景：")])]),r._v(" "),a("ol",[a("li",[r._v("consumer宕机，消费了一半的消息没有提交，触发rebalance，重新选去一个consumer消费，新的consumer拉取消息时还是按照旧的offset位置进行拉取，从而出现原consumer和新consumer会重复消费部分消息")]),r._v(" "),a("li",[r._v("consumer超过固定时间（session time：默认5s，最大10s）没有向broker发送心跳（每隔3s发送一次），broker认为consumer已经离线，触发rebalance，选择新的cosumer")]),r._v(" "),a("li",[r._v("消费超时，consumer一次拉取（默认500）条数据进行消费，但是处理500条的时间超过规定的响应时间（5min），broker会认为consumer消费能力不够，重新选择新的consumer")])]),r._v(" "),a("p",[a("em",[r._v("解决办法：")])]),r._v(" "),a("ol",[a("li",[r._v("需要在consumer端做好幂等处理")]),r._v(" "),a("li",[r._v("另外根据业务实际情况对配置做一些修改，比如consumer消息确认的响应时间可以适当放大等等")])]),r._v(" "),a("h3",{attrs:{id:"kafka如何保证消息不丢失"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka如何保证消息不丢失"}},[r._v("#")]),r._v(" kafka如何保证消息不丢失")]),r._v(" "),a("p",[a("strong",[r._v("丢失场景：")])]),r._v(" "),a("ol",[a("li",[r._v("producer丢失：")])]),r._v(" "),a("ul",[a("li",[r._v("ack配置：\n"),a("ul",[a("li",[a("p",[a("strong",[r._v("1")]),r._v(" ：默认值，代表producer发送给broker之后，broker要将数据写入leader partition才会返回ack确认；")])]),r._v(" "),a("li",[a("p",[a("strong",[r._v("0")]),r._v(" ：代表broker接收到消息之后立刻响应ack；")])]),r._v(" "),a("li",[a("p",[a("strong",[r._v("-1或all")]),r._v(" ：代表broker接收消息后，leader和isr列表中的follower都要卸乳成功才能响应ack")]),r._v(" "),a("p",[a("strong",[r._v("解决办法：")])]),r._v(" "),a("ul",[a("li",[r._v("ack配置为-1或者1，按实际业务情况，配合producer配置重试次数进行重试")]),r._v(" "),a("li",[r._v("发送消息时使用带回调的方法发送，失败时可以回调producer进行业务处理")])])])])])]),r._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[a("strong",[r._v("broker丢失")]),r._v("：broker内部使用"),a("code",[r._v("异步刷盘")]),r._v("策略，先写缓存再刷盘，如果写完缓存，broker宕机，数据就会丢失；")]),r._v(" "),a("p",[r._v("**解决办法：**多副本数据备份")])]),r._v(" "),a("li",[a("p",[a("strong",[r._v("consumer丢失：")]),r._v(" 自动提交offset，如果consumer还没有消费完，就进行了自动提交，此时consumer异常，这个消息就丢失了")]),r._v(" "),a("p",[a("strong",[r._v("解决办法：")]),r._v(" 需要设置为手动提交，consumer执行完成后再提交offset")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);