"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePageComponentInfo = void 0;
const utils_1 = require("@vuepress/utils");
/**
 * Resolve page component and related info
 */
const resolvePageComponentInfo = async ({ app, content, filePathRelative, path: routePath, key, }) => {
    var _a;
    const markdownEnv = {
        base: app.options.base,
        filePathRelative,
    };
    const rendered = app.markdown.render(content, markdownEnv);
    const { headers = [], links = [], hoistedTags = [] } = markdownEnv;
    // TODO: links check
    // resolve component file content
    // take the rendered markdown content as <template>
    // hoist `<script>`, `<style>` and other custom blocks
    const componentFileContent = [
        // if the `<template>` block is empty, vue will print a runtime warning
        // during development, so here we add a whitespace to temporarily avoid
        // the warning
        // @see https://github.com/vuejs/vue-next/issues/2463
        `<template>${rendered || ' '}</template>`,
        ...hoistedTags,
    ].join('\n\n');
    // resolve component file path
    const componentFilePathRelative = utils_1.path.join('pages', (_a = filePathRelative === null || filePathRelative === void 0 ? void 0 : filePathRelative.replace(/\.md$/, '.vue')) !== null && _a !== void 0 ? _a : `${routePath || key}.vue`);
    const componentFilePath = app.dir.temp(componentFilePathRelative);
    const componentFileChunkName = key;
    return {
        headers,
        links,
        componentFilePath,
        componentFilePathRelative,
        componentFileContent,
        componentFileChunkName,
    };
};
exports.resolvePageComponentInfo = resolvePageComponentInfo;
