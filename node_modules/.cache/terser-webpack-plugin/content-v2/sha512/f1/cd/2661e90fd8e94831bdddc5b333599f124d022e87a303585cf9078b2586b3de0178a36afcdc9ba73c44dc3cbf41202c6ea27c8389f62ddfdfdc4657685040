{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{292:function(s,_,v){\"use strict\";v.r(_);var t=v(7),e=Object(t.a)({},(function(){var s=this,_=s._self._c;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[_(\"h1\",{attrs:{id:\"redis\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis\"}},[s._v(\"#\")]),s._v(\" Redis\")]),s._v(\" \"),_(\"h2\",{attrs:{id:\"一、基于内存实现\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、基于内存实现\"}},[s._v(\"#\")]),s._v(\" 一、基于内存实现\")]),s._v(\" \"),_(\"p\",[s._v(\"​\\t内存读写速度远高于磁盘，内存的响应时间约为100纳秒。\")]),s._v(\" \"),_(\"h2\",{attrs:{id:\"二、数据结构\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、数据结构\"}},[s._v(\"#\")]),s._v(\" 二、数据结构\")]),s._v(\" \"),_(\"h3\",{attrs:{id:\"_1-字符串-sds-简单动态字符串\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-字符串-sds-简单动态字符串\"}},[s._v(\"#\")]),s._v(\" 1. 字符串（SDS-简单动态字符串）\")]),s._v(\" \"),_(\"p\",[s._v(\"SDS的结构：\")]),s._v(\" \"),_(\"p\",[s._v(\"char[] buff; //字符数组\")]),s._v(\" \"),_(\"p\",[s._v(\"int len; //字符串长度\")]),s._v(\" \"),_(\"p\",[s._v(\"int free; //buff字段中没有使用的长度\")]),s._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/images/redis/redis%E5%AD%98%E5%82%A8%E5%AD%97%E7%AC%A6%E4%B8%B2.png\",alt:\"redis存储字符串\"}})]),s._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[s._v(\"优势：\")]),s._v(\" \"),_(\"p\",[_(\"strong\",[s._v(\"长度计算\")]),s._v(\"：Redis可以直接调用获取长度的方法（strlen）。\")]),s._v(\" \"),_(\"p\",[_(\"strong\",[s._v(\"字符串变更操作\")]),s._v(\"：因为他的内存分配和释放策略，可以高效的对字符串进行追加和缩短。\")]),s._v(\" \"),_(\"ul\",[_(\"li\",[s._v(\"空间预分配：\")])]),s._v(\" \"),_(\"p\",[s._v(\"小于1M的字符串，分配时为原长+等长+1字节。如某字符串长度=5，初始分配长度=5+5+1=11；\")]),s._v(\" \"),_(\"p\",[s._v(\"大于1M的字符串，分配时为原长+1M+1字节，如某字符串初始大小为3M，则分配内存=3M+1M+1Byte；\")]),s._v(\" \"),_(\"ul\",[_(\"li\",[s._v(\"空间惰性释放：\")])]),s._v(\" \"),_(\"p\",[s._v(\"上图的redis，变成red，内存无需释放，len->3, free->7；\")])])]),s._v(\" \"),_(\"h3\",{attrs:{id:\"_2-链表-双向无环链表-list-listnode\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-链表-双向无环链表-list-listnode\"}},[s._v(\"#\")]),s._v(\" 2. 链表（双向无环链表 list+listNode）\")]),s._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/images/redis/redis%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.jpeg\",alt:\"redis链表结构\"}})]),s._v(\" \"),_(\"p\",[s._v(\"优势：\")]),s._v(\" \"),_(\"ul\",[_(\"li\",[s._v(\"双向\")]),s._v(\" \"),_(\"li\",[s._v(\"无环\")]),s._v(\" \"),_(\"li\",[s._v(\"list中明确了表头，表尾以及长度\")])]),s._v(\" \"),_(\"h3\",{attrs:{id:\"_3-压缩列表-ziplist\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-压缩列表-ziplist\"}},[s._v(\"#\")]),s._v(\" 3. 压缩列表（ziplist）\")]),s._v(\" \"),_(\"ul\",[_(\"li\",[s._v(\"连续的内存空间\")]),s._v(\" \"),_(\"li\",[s._v(\"给每个节点增加一个length属性\")])]),s._v(\" \"),_(\"p\",[s._v(\"简单压缩列表：\")]),s._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/images/redis/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A81.png\",alt:\"压缩列表\"}})]),s._v(\" \"),_(\"p\",[s._v(\"Redis压缩列表结构示例：\")]),s._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/images/redis/redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png\",alt:\"redis压缩列表结构示例\"}})]),s._v(\" \"),_(\"p\",[s._v(\"entry说明：\")]),s._v(\" \"),_(\"p\",[_(\"b\",[s._v(\"prevlength（8位）\")]),s._v(\"：上一个节点的长度（方便反向遍历）。\")]),s._v(\" \"),_(\"p\",[s._v(\"​\\t当prevlength<254时，该值就代表上一个节点的真实长度；\")]),s._v(\" \"),_(\"p\",[s._v(\"​\\t当prevlength>=254时，该节点的前8位无法表示真实长度，从第8位开始的后面32位才是上一个节点的长度。\")]),s._v(\" \"),_(\"p\",[_(\"b\",[s._v(\"encoding\")]),s._v(\"：指当前节点的编码规则\")]),s._v(\" \"),_(\"p\",[_(\"b\",[s._v(\"data\")]),s._v(\"：当前节点值\")]),s._v(\" \"),_(\"h3\",{attrs:{id:\"_4-字典-哈希表\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-字典-哈希表\"}},[s._v(\"#\")]),s._v(\" 4. 字典（哈希表）\")]),s._v(\" \"),_(\"p\",[s._v(\"基于散列，但因为散列函数会出现散列冲突，解决散列冲突的两种方法：开放寻址法和链表法\")]),s._v(\" \"),_(\"p\",[s._v(\"Redis的实现：\")]),s._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/images/redis/redis%E5%AD%97%E5%85%B8.jpeg\",alt:\"redis字典.jpeg\"}})]),s._v(\" \"),_(\"h4\",{attrs:{id:\"_5-跳跃表-多级索引\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-跳跃表-多级索引\"}},[s._v(\"#\")]),s._v(\" 5. 跳跃表（多级索引）\")]),s._v(\" \"),_(\"p\",[s._v(\"什么是跳跃表？\")]),s._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/images/redis/%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8.png\",alt:\"一层跳跃表.png\"}})]),s._v(\" \"),_(\"p\",[s._v(\"redis的跳跃表是有序集合（zSet）的其中一个实现，如果有序集合的元素大于128个或者集合中元素长度大于64，就会使用跳跃表，否则使用压缩列表。\")]),s._v(\" \"),_(\"p\",[s._v(\"**redis跳跃表的实现：**skipList + zskipListNode\")]),s._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/images/redis/Redis%E8%B7%B3%E8%B7%83%E8%A1%A8.png\",alt:\"redis跳跃表.png\"}})]),s._v(\" \"),_(\"p\",[s._v(\"蓝色指skipList，右边部分是多个zskipListNode\")]),s._v(\" \"),_(\"p\",[s._v(\"skipList结构：\")]),s._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[s._v(\"header：指向第一个zskipListNode\")])]),s._v(\" \"),_(\"li\",[_(\"p\",[s._v(\"tail：指向最后一个zskipListNode\")])]),s._v(\" \"),_(\"li\",[_(\"p\",[s._v(\"level：当前跳跃表中层数最大的zskipListNode（头节点不算在内）\")])]),s._v(\" \"),_(\"li\",[_(\"p\",[s._v(\"length：当前跳跃表的长度，即zskipListNode的数量（头节点不算在内）\")])])]),s._v(\" \"),_(\"p\",[s._v(\"zskiplistNode结构：\")]),s._v(\" \"),_(\"ul\",[_(\"li\",[s._v(\"level：层，L1代表第一层，L2代表第二层。每一个level都有两个属性，一个是前进指针，一个是跨度。\")]),s._v(\" \"),_(\"li\",[s._v(\"backward（后退）：当前zskiplistNode的前一个节点\")]),s._v(\" \"),_(\"li\",[s._v(\"score：排序使用\")]),s._v(\" \"),_(\"li\",[s._v(\"对象：各节点保存的成员对象的指针，指向实际保存的地址。\")])]),s._v(\" \"),_(\"h2\",{attrs:{id:\"三、线程模型\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、线程模型\"}},[s._v(\"#\")]),s._v(\" 三、线程模型\")]),s._v(\" \"),_(\"h3\",{attrs:{id:\"_1-文件事件处理器\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-文件事件处理器\"}},[s._v(\"#\")]),s._v(\" 1. \"),_(\"strong\",[s._v(\"文件事件处理器\")])]),s._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/images/redis/%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png\",alt:\"文件事件处理器.png\"}})]),s._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[s._v(\"套接字（socket）\")]),s._v(\" \"),_(\"p\",[s._v(\"客户端连接、读写等操作请求，server socket根据这些请求产生文件事件，文件事件包括AE_READABLE，AE_WRITABLE，redis服务端可读，可连接产生的是AE_READABLE，可写产生的是AE_WRITABLE事件。\")])]),s._v(\" \"),_(\"li\",[_(\"p\",[s._v(\"I/O多路复用程序\")]),s._v(\" \"),_(\"p\",[s._v(\"作用是用来监听server socket，并将这些socket顺序的放入队列中。\")])]),s._v(\" \"),_(\"li\",[_(\"p\",[s._v(\"文件事件分派器\")]),s._v(\" \"),_(\"p\",[s._v(\"接收队列中的socket，并将socket中的文件事件类型与对应的事件处理器关联，根据对应的事件处理器进行操作。\")])]),s._v(\" \"),_(\"li\",[_(\"p\",[s._v(\"事件处理器\")]),s._v(\" \"),_(\"ul\",[_(\"li\",[s._v(\"连接应答处理器：redis服务器初始化时，关联服务器监听套接字产生的AE_READABLE事件。事件在客户端connect时产生，创建套接字。\")]),s._v(\" \"),_(\"li\",[s._v(\"命令请求处理器：客户端连接成功后，关联客户端套接字的AE_READABLE事件。\")]),s._v(\" \"),_(\"li\",[s._v(\"命令回复处理器：服务器有命令回复需要传送给客户端时，关联客户端套接字的AE_WRITABLE事件。事件在客户端尝试读取时产生。\")])])])]),s._v(\" \"),_(\"p\",[_(\"strong\",[s._v(\"完整通信过程：\")])]),s._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"/images/redis/%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png\",alt:\"通信过程\"}})]),s._v(\" \"),_(\"h3\",{attrs:{id:\"_2-时间事件处理器\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-时间事件处理器\"}},[s._v(\"#\")]),s._v(\" 2.时间事件处理器\")]),s._v(\" \"),_(\"ul\",[_(\"li\",[s._v(\"刷新服务器信息\")]),s._v(\" \"),_(\"li\",[s._v(\"清理过期的key\")]),s._v(\" \"),_(\"li\",[s._v(\"持久化\")])]),s._v(\" \"),_(\"p\",[_(\"strong\",[s._v(\"为什么说Redis是单线程实现的？\")])]),s._v(\" \"),_(\"p\",[s._v(\"-- redis内部使用文件事件处理器（file event handler），因为文件事件处理器在执行redis命令请求时是单线程执行的，而文件事件处理器是redis的核心，所以说redis是单线程的。\")]),s._v(\" \"),_(\"p\",[s._v(\"实际上redis从4.0版本开始，删除对象的操作也开始使用多线程处理。\")]),s._v(\" \"),_(\"h2\",{attrs:{id:\"redis热key问题\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis热key问题\"}},[s._v(\"#\")]),s._v(\" Redis热key问题\")]),s._v(\" \"),_(\"h3\",{attrs:{id:\"一、什么是热key\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、什么是热key\"}},[s._v(\"#\")]),s._v(\" 一、什么是热key\")]),s._v(\" \"),_(\"p\",[s._v(\"瞬间有大量请求去访问redis上某个固定的key，导致redis服务器宕机。某些业务下如果redis服务不可用，则会请求数据库，导致数据库服务无法使用。\")]),s._v(\" \"),_(\"h3\",{attrs:{id:\"二、如何解决\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、如何解决\"}},[s._v(\"#\")]),s._v(\" 二、如何解决\")]),s._v(\" \"),_(\"h4\",{attrs:{id:\"_1-监控\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-监控\"}},[s._v(\"#\")]),s._v(\" 1. 监控\")]),s._v(\" \"),_(\"ul\",[_(\"li\",[s._v(\"客户端收集：在调用redis服务的时候，增加一层监控，对所有rediskey进行ump监控。\")]),s._v(\" \"),_(\"li\",[s._v(\"redis服务集群代理：在redis服务器集群上做一层代理，所有请求经过这个代理，从而通过这个代理进行统一监控\")]),s._v(\" \"),_(\"li\",[s._v(\"redis自带命令：\\n\"),_(\"ul\",[_(\"li\",[s._v(\"monitor命令-可实时抓取redis服务器接收到的命令，需要单独开发统计的逻辑代码。\")]),s._v(\" \"),_(\"li\",[s._v(\"hotkeys参数-4.0.3版本以后加入，需要在客户端启动时增加-hotkeys参数。key比较多的情况下执行速度很慢。\")])])])]),s._v(\" \"),_(\"h4\",{attrs:{id:\"_2-解决方案\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-解决方案\"}},[s._v(\"#\")]),s._v(\" 2. 解决方案：\")]),s._v(\" \"),_(\"p\",[_(\"strong\",[s._v(\"客户端缓存：\")])]),s._v(\" \"),_(\"p\",[s._v(\"redis服务器发现热key后，通过sdk把热key写入到客户端的本地缓存中，当key发生了写操作的时候，再把这个key从本地缓存中删除。\")])])}),[],!1,null,null,null);_.default=e.exports}}]);","extractedComments":[]}