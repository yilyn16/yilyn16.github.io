# 隔离级别

## 什么是事务

事务是逻辑上的一组操作，要么全执行，要么全不执行。

## 事务的特性（ACID）

1. 原子性：事务最小的执行单位，不允许分割。事务的原子性确保动作要么全部执行，要么全部不执行。
2. 一致性：执行事务的前后，数据保持一致。例如转账的业务中，无论事务是否成功，转账者和收款人的总额应该是不变的。
3. 隔离性：并发访问数据库时，一个用户的事务不应该被其他事务所影响，各并发事务之间数据库是独立的。
4. 持久性：一个事务被提交后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有影响。

## MySQL的事物隔离级别

1. 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
2. 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
3. 事务用来管理 insert,update,delete 语句。


| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|-------|--|-----|--|
| 读取未提交(RU) | 是| 是 | 是 |
| 读取已提交(RC) | 否| 是 | 是 |
| 可重复度(RR)  | 否 | 否 | 是 |
| 串行化 | 否 | 否 | 否 |


### 读取未提交(READ UNCOMMITTED)

> 事务A读取了事务B还未提交的数据

1. 如果B事物进行了回滚，此时A读到的数据就是脏数据，这种现象叫做**脏读**
2. 如果事务B又更新事务A读取的数据，那么事务A再次读取，读取到了事务B修改的结果，这种情况叫**不可重复读**
3. 如果事物B新增了数据，此时事务A再次读取，读到了事物B新增的数据，从而造成**幻读**

### 读取已提交（READ COMMITTED）

> 事务A读取了事务B已经提交的数据

1. 事务B更新了事物A读取到的数据，并且提交，当事物A再次读取时，就会读取到事物B更新的数据，产生**不可重复读**
2. 如果事物B新增了数据，此时事务A再次读取，读到了事物B新增的数据，从而造成**幻读**

### 可重复读（REPEATABLE READ）

> InnoDB默认的隔离级别，事务A不会读取到事务B更新的数据，也不会读到事务B新增的数据

1. 可重复读不会出现脏读，不可重复读的问题，可能出现幻读（当使用当前读的时候就会读取到其他事物提交的数据）。

## MVCC如何解决不可重复读和幻读问题

MVCC是为了提高读-写并发处理能力，做到读-写冲突时不加锁。这里会引入两个锁的概念，一个是`当前读`，一个是`快照读`，MVCC使用的是`快照读`。

### 快照读
1. 快照读的前提是非串行化的隔离级别，如果是串行化，则会变成当前读。
2. 普通的select（不加锁）就是快照读，不会加锁，不阻塞。

### 当前读
1. select lock in share mode(共享锁), select for update ; update, insert ,delete 这些操作都是当前读，读取到的数据是最新的，会对记录加锁。

### MVCC的实现

MVCC的实现是通过4个隐藏字段、undo log和Read View实现的

1. 隐藏字段
   每行记录在存储数据的同时，会存在隐藏的字段：

+ DB_ROW_ID：隐藏主键
+ DB_TRX_ID: 最新的一次修改对应的事物ID
+ DB_ROLL_PTR: 回滚指针，指向上一次修改的事物ID
+ DELETED_BIT: 删除flag

2. undo log
   记录了对数据增删改时的一些类似快照数据，分为`Insert undo log`,`Update undo log`,`Delete undo log`, 比如当前有一条刚刚被insert的记录：
+ 事物1修改这条数据，对这一行记录加锁，将当前行的DB_TRX_ID改为自己的事物ID，然后DB_ROLL_PTR指向insert时产生的undo log上，然后释放锁；
+ 事物2修改这条记录，对这一行记录加锁，将当前行的DB_TRX_ID改为自己的事物ID，然后DB_ROLL_PTR指向事物1产生的undo log上，然后释放锁；

这样就形成了一个版本链

3. Read View
   事物进行快照读的时候产生的读视图，会记录事物在开始快照读之后还活跃的事物ids，还有up_limit_id（活跃事物中的最小事物id），low_limit_id（活跃事物中最大id的下一个事物id）。