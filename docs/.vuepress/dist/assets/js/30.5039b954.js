(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{307:function(e,n,t){"use strict";t.r(n);var a=t(7),r=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"netty"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#netty"}},[e._v("#")]),e._v(" Netty")]),e._v(" "),n("p",[e._v("Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。Netty 提供高性能和可扩展性，让你可以自由地专注于你真正感兴趣的东西，你的独特的应用！")]),e._v(" "),n("p",[e._v("参考书籍：\n"),n("a",{attrs:{href:"https://www.bookstack.cn/read/essential-netty-in-action/SUMMARY.md"}},[e._v("Netty实战")])]),e._v(" "),n("h2",{attrs:{id:"netty的基本构建模块"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#netty的基本构建模块"}},[e._v("#")]),e._v(" Netty的基本构建模块")]),e._v(" "),n("h3",{attrs:{id:"bootstrap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bootstrap"}},[e._v("#")]),e._v(" BootStrap")]),e._v(" "),n("p",[e._v("Netty 应用程序通过设置 bootstrap（引导）类的开始，该类提供了一个用于应用程序网络层配置的容器。服务端：ServerBootStrap，客户端：BootStrap")]),e._v(" "),n("h3",{attrs:{id:"channel"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channel"}},[e._v("#")]),e._v(" Channel")]),e._v(" "),n("p",[e._v("底层网络传输 API 必须提供给应用 I/O操作的接口，如读，写，连接，绑定等等。对于我们来说，这是结构几乎总是会成为一个“socket”。 Netty 中的接口 Channel 定义了与 socket 丰富交互的操作集：bind, close, config, connect, isActive, isOpen, isWritable, read, write 等等。 Netty 提供大量的 Channel 实现来专门使用。这些包括AbstractChannel，AbstractNioByteChannel，AbstractNioChannel，EmbeddedChannel，\nLocalServerChannel，NioSocketChannel 等等。")]),e._v(" "),n("h3",{attrs:{id:"channelhandler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler"}},[e._v("#")]),e._v(" ChannelHandler")]),e._v(" "),n("p",[e._v("ChannelHandler 支持很多协议，并且提供用于数据处理的容器。我们已经知道 ChannelHandler 由特定事件触发。 ChannelHandler\n可专用于几乎所有的动作，包括将一个对象转为字节（或相反），执行过程中抛出的异常处理。")]),e._v(" "),n("p",[e._v("常用的一个接口是 ChannelInboundHandler，这个类型接收到入站事件（包括接收到的数据）可以处理应用程序逻辑。当你需要提供响应时，你也可以从 ChannelInboundHandler 冲刷数据。一句话，业务逻辑经常存活于一个或者多个 ChannelInboundHandler。")]),e._v(" "),n("h3",{attrs:{id:"channelpipeline"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelpipeline"}},[e._v("#")]),e._v(" ChannelPipeline")]),e._v(" "),n("p",[e._v("ChannelPipeline 提供了一个容器给 ChannelHandler 链并提供了一个API 用于管理沿着链入站和出站事件的流动。每个 Channel 都有自己的ChannelPipeline，当 Channel 创建时自动创建的。")]),e._v(" "),n("p",[e._v("ChannelHandler 是如何安装在 ChannelPipeline？ 主要是实现了ChannelHandler 的抽象 ChannelInitializer。ChannelInitializer子类 通过 ServerBootstrap 进行注册。当它的方法 initChannel() 被调用时，这个对象将安装自定义的 ChannelHandler 集到 pipeline。当这个操作完成时，ChannelInitializer 子类则从 ChannelPipeline 自动删除自身。")]),e._v(" "),n("h3",{attrs:{id:"eventloop"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[e._v("#")]),e._v(" EventLoop")]),e._v(" "),n("p",[e._v("EventLoop 用于处理 Channel 的 I/O 操作。一个单一的 EventLoop通常会处理多个 Channel 事件。一个 EventLoopGroup 可以含有多于一个的 EventLoop 和 提供了一种迭代用于检索清单中的下一个。")]),e._v(" "),n("h3",{attrs:{id:"channelfuture"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelfuture"}},[e._v("#")]),e._v(" CHANNELFUTURE")]),e._v(" "),n("p",[e._v("Netty 所有的 I/O 操作都是异步。因为一个操作可能无法立即返回，我们需要有一种方法在以后确定它的结果。出于这个目的，Netty 提供了接口 ChannelFuture,它的 addListener 方法注册了一个 ChannelFutureListener ，当操作完成时，可以被通知（不管成功与否）。")])])}),[],!1,null,null,null);n.default=r.exports}}]);