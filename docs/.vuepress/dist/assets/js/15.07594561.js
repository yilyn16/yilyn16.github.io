(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{295:function(s,_,v){"use strict";v.r(_);var t=v(7),e=Object(t.a)({},(function(){var s=this,_=s._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[_("h1",{attrs:{id:"redis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[s._v("#")]),s._v(" Redis")]),s._v(" "),_("p",[s._v("Redis是当下最流行的NoSQL数据库之一，可以应用于数据库，缓存和消息队列等场景。具有较多优点：")]),s._v(" "),_("ol",[_("li",[s._v("性能极高")]),s._v(" "),_("li",[s._v("数据类型丰富，单键值对最大支持512M大小的数据")]),s._v(" "),_("li",[s._v("简单易用，支持几乎所有的主流编程语言")]),s._v(" "),_("li",[s._v("支持持久化，支持主从、哨兵和Cluster等高可用模式")])]),s._v(" "),_("h2",{attrs:{id:"一、数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、数据类型"}},[s._v("#")]),s._v(" 一、数据类型")]),s._v(" "),_("h3",{attrs:{id:"基础数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础数据类型"}},[s._v("#")]),s._v(" 基础数据类型")]),s._v(" "),_("ol",[_("li",[s._v("String")]),s._v(" "),_("li",[s._v("Hash")]),s._v(" "),_("li",[s._v("List")]),s._v(" "),_("li",[s._v("Set")]),s._v(" "),_("li",[s._v("ZSet")])]),s._v(" "),_("h3",{attrs:{id:"高级数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高级数据类型"}},[s._v("#")]),s._v(" 高级数据类型")]),s._v(" "),_("ol",[_("li",[s._v("消息队列 Stream")]),s._v(" "),_("li",[s._v("地理空间 GeoSpatial")]),s._v(" "),_("li",[s._v("HyperLogLog")]),s._v(" "),_("li",[s._v("位图 Bitmap")]),s._v(" "),_("li",[s._v("位域 BitField")])]),s._v(" "),_("h2",{attrs:{id:"二、持久化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、持久化"}},[s._v("#")]),s._v(" 二、持久化")]),s._v(" "),_("p",[s._v("Redis数据存储在内存中，如果服务器宕机，内存中的数据将会丢失，对于一个数据库而言是非常致命的。所以Redis官方提供了两种数据持久化的方式")]),s._v(" "),_("h3",{attrs:{id:"rdb-redis-database"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rdb-redis-database"}},[s._v("#")]),s._v(" RDB (Redis Database)")]),s._v(" "),_("p",[s._v("在指定的间隔时间内，将内存中的数据快照写入磁盘，是某个时间点上数据的完整副本，通过配置文件中的save参数配置，表示规定时间内有多少次数据修改就进行一次快照存储")]),s._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[s._v("save <seconds> <changes>\n")])]),s._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[s._v("1")]),_("br")])]),_("p",[s._v("RDB 存在的问题：")]),s._v(" "),_("ol",[_("li",[s._v("如果服务器宕机，最后一次的快照数据就会丢失。")]),s._v(" "),_("li",[s._v("快照会存储当前内存中的所有数据，每次生成快照所需时间太久，在生成快照这段时间内Redis是一个阻塞的状态，不能接收请求。 所以Redis提供了bgsave命令，这个命令会fork子进程来进行快照生成，不会影响客户端。")])]),s._v(" "),_("h3",{attrs:{id:"aof-append-only-file"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof-append-only-file"}},[s._v("#")]),s._v(" AOF (Append-Only File)")]),s._v(" "),_("p",[s._v("AOF是以日志追加的形式存储数据的，在写入数据时，即写入内存，也会写入追加文件，写入策略分为如下几种：")]),s._v(" "),_("ol",[_("li",[s._v("always:每次写入数据都写aof文件，性能最差，但是最安全。")]),s._v(" "),_("li",[s._v("EverySec: 每秒追加一次，是一种平衡的方案，可能会丢失一秒钟的数据。")]),s._v(" "),_("li",[s._v("No: 数据写入内存后结束，由操作系统决定何时追加到aof文件，最不安全。")])]),s._v(" "),_("h4",{attrs:{id:"aof重写"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof重写"}},[s._v("#")]),s._v(" AOF重写")]),s._v(" "),_("p",[s._v("随着数据不断写入，并且一些key会多次重复操作，导致AOF文件会越来越大，写入速度也会越来越慢，使用该文件进行数据恢复时，速度会很慢。")]),s._v(" "),_("p",[s._v("所以Redis官方推出AOF重写机制，在子进程中生成一个新的AOF文件，只将当前有效数据进行追加写入，比如某个key1，对其进行了1W次的修改，那么新的AOF文件值存储最新的一次修改记录即可。这种方式可以有效的降低文件大小。")]),s._v(" "),_("h2",{attrs:{id:"三、集群模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、集群模式"}},[s._v("#")]),s._v(" 三、集群模式")]),s._v(" "),_("h3",{attrs:{id:"主从模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主从模式"}},[s._v("#")]),s._v(" 主从模式")]),s._v(" "),_("p",[s._v("由多个节点构成，包括一个主节点Master和一个或多个从节点Slave，Master节点负责读写，Slave节点负责读。")]),s._v(" "),_("p",[s._v("主从模式比较大的问题在于当Master节点宕机后，整个集群无法提供写的服务，需要手动将某个Slave节点切换为Master节点才能继续提供服务，无法提供真正的高可用。")]),s._v(" "),_("h3",{attrs:{id:"哨兵模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式"}},[s._v("#")]),s._v(" 哨兵模式")]),s._v(" "),_("p",[s._v("哨兵模式很好的解决了主从模式的问题，在该模式下，会有单独的哨兵进程存在于Redis集群中。哨兵具有以下两个功能：")]),s._v(" "),_("ol",[_("li",[s._v("监控：监控各个Redis节点状态是否正常")]),s._v(" "),_("li",[s._v("通知：如果某个主节点出现问题，哨兵会通过发布/订阅模式通知其他哨兵")]),s._v(" "),_("li",[s._v("故障转移：通知其他哨兵后，会进行下线、重新选主的流程，选举出新的Master节点。")])]),s._v(" "),_("h4",{attrs:{id:"哨兵模式下的主从切换过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式下的主从切换过程"}},[s._v("#")]),s._v(" 哨兵模式下的主从切换过程")]),s._v(" "),_("ol",[_("li",[_("strong",[s._v("监控")]),s._v("\nsentinal每隔1s向各个节点发送ping命令，持续的监控master节点的状态")]),s._v(" "),_("li",[_("strong",[s._v("下线（主观下线、客观下线）")]),s._v("\n如果sentinal发送的ping命令在规定的时间内没有相应，则sentinal会将这个节点标记为主观下线；\n这个时候当前sentinal会告知其他哨兵节点，其他哨兵会确认与master的连接情况，如果超过半数的sentinal都认为master节点无法提供服务，那么master节点就进入客观下线状态")]),s._v(" "),_("li",[_("strong",[s._v("选主")]),s._v("\nmaster进入客观下线状态后，开始选主任务；\n选主时会先对从节点进行过滤，过滤掉没有连接的，或者网络不稳定的从节点之后进入打分阶段；\n打分时根据由高到低的优先级： 从库的优先级、从库数据复制进度、从库id号（从低到高排），计算出的分数最高的从节点获胜，升级为主节点")])]),s._v(" "),_("h3",{attrs:{id:"cluster模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cluster模式"}},[s._v("#")]),s._v(" Cluster模式")]),s._v(" "),_("h2",{attrs:{id:"redis的事物"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis的事物"}},[s._v("#")]),s._v(" Redis的事物")]),s._v(" "),_("p",[s._v("Redis的事物是在一次请求中执行多个命令，使用"),_("code",[s._v("MULTI")]),s._v("和"),_("code",[s._v("EXEC/DISCARD")]),s._v("实现。MULTI用来开启事物，开启后，后序所有的命令都会放到一个队列中，最后通过EXEC命令来执行队列中的所有命令，用DISCARD命令来取消命令。")]),s._v(" "),_("p",[s._v("Redis中的事物和我们常见的关系型数据库的事物不太一样，Redis事物中的命令不会因为某个命令执行失败而导致所有命令都失败，如果某一个命令执行失败了，那么其他命令也会继续执行，不会受到影响。")]),s._v(" "),_("h2",{attrs:{id:"一、基于内存实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、基于内存实现"}},[s._v("#")]),s._v(" 一、基于内存实现")]),s._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[s._v("内存读写速度远高于磁盘，内存的响应时间约为100纳秒。\n")])])]),_("h2",{attrs:{id:"二、数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、数据结构"}},[s._v("#")]),s._v(" 二、数据结构")]),s._v(" "),_("h3",{attrs:{id:"_1-字符串-sds-简单动态字符串"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-字符串-sds-简单动态字符串"}},[s._v("#")]),s._v(" 1. 字符串（SDS-简单动态字符串）")]),s._v(" "),_("p",[s._v("SDS的结构：")]),s._v(" "),_("p",[s._v("char[] buff; //字符数组")]),s._v(" "),_("p",[s._v("int len; //字符串长度")]),s._v(" "),_("p",[s._v("int free; //buff字段中没有使用的长度")]),s._v(" "),_("p",[_("img",{attrs:{src:"/images/redis/redis%E5%AD%98%E5%82%A8%E5%AD%97%E7%AC%A6%E4%B8%B2.png",alt:"redis存储字符串"}})]),s._v(" "),_("ul",[_("li",[_("p",[s._v("优势：")]),s._v(" "),_("p",[_("strong",[s._v("长度计算")]),s._v("：Redis可以直接调用获取长度的方法（strlen）。")]),s._v(" "),_("p",[_("strong",[s._v("字符串变更操作")]),s._v("：因为他的内存分配和释放策略，可以高效的对字符串进行追加和缩短。")]),s._v(" "),_("ul",[_("li",[s._v("空间预分配：")])]),s._v(" "),_("p",[s._v("小于1M的字符串，分配时为原长+等长+1字节。如某字符串长度=5，初始分配长度=5+5+1=11；")]),s._v(" "),_("p",[s._v("大于1M的字符串，分配时为原长+1M+1字节，如某字符串初始大小为3M，则分配内存=3M+1M+1Byte；")]),s._v(" "),_("ul",[_("li",[s._v("空间惰性释放：")])]),s._v(" "),_("p",[s._v("上图的redis，变成red，内存无需释放，len->3, free->7；")])])]),s._v(" "),_("h3",{attrs:{id:"_2-链表-双向无环链表-list-listnode"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-链表-双向无环链表-list-listnode"}},[s._v("#")]),s._v(" 2. 链表（双向无环链表 list+listNode）")]),s._v(" "),_("p",[_("img",{attrs:{src:"/images/redis/redis%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.jpeg",alt:"redis链表结构"}})]),s._v(" "),_("p",[s._v("优势：")]),s._v(" "),_("ul",[_("li",[s._v("双向")]),s._v(" "),_("li",[s._v("无环")]),s._v(" "),_("li",[s._v("list中明确了表头，表尾以及长度")])]),s._v(" "),_("h3",{attrs:{id:"_3-压缩列表-ziplist"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-压缩列表-ziplist"}},[s._v("#")]),s._v(" 3. 压缩列表（ziplist）")]),s._v(" "),_("ul",[_("li",[s._v("连续的内存空间")]),s._v(" "),_("li",[s._v("给每个节点增加一个length属性")])]),s._v(" "),_("p",[s._v("简单压缩列表：")]),s._v(" "),_("p",[_("img",{attrs:{src:"/images/redis/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A81.png",alt:"压缩列表"}})]),s._v(" "),_("p",[s._v("Redis压缩列表结构示例：")]),s._v(" "),_("p",[_("img",{attrs:{src:"/images/redis/redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png",alt:"redis压缩列表结构示例"}})]),s._v(" "),_("p",[s._v("entry说明：")]),s._v(" "),_("p",[_("b",[s._v("prevlength（8位）")]),s._v("：上一个节点的长度（方便反向遍历）。")]),s._v(" "),_("p",[s._v("​\t当prevlength<254时，该值就代表上一个节点的真实长度；")]),s._v(" "),_("p",[s._v("​\t当prevlength>=254时，该节点的前8位无法表示真实长度，从第8位开始的后面32位才是上一个节点的长度。")]),s._v(" "),_("p",[_("b",[s._v("encoding")]),s._v("：指当前节点的编码规则")]),s._v(" "),_("p",[_("b",[s._v("data")]),s._v("：当前节点值")]),s._v(" "),_("h3",{attrs:{id:"_4-字典-哈希表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-字典-哈希表"}},[s._v("#")]),s._v(" 4. 字典（哈希表）")]),s._v(" "),_("p",[s._v("基于散列，但因为散列函数会出现散列冲突，解决散列冲突的两种方法：开放寻址法和链表法")]),s._v(" "),_("p",[s._v("Redis的实现：")]),s._v(" "),_("p",[_("img",{attrs:{src:"/images/redis/redis%E5%AD%97%E5%85%B8.jpeg",alt:"redis字典.jpeg"}})]),s._v(" "),_("h4",{attrs:{id:"_5-跳跃表-多级索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-跳跃表-多级索引"}},[s._v("#")]),s._v(" 5. 跳跃表（多级索引）")]),s._v(" "),_("p",[s._v("什么是跳跃表？")]),s._v(" "),_("p",[_("img",{attrs:{src:"/images/redis/%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8.png",alt:"一层跳跃表.png"}})]),s._v(" "),_("p",[s._v("redis的跳跃表是有序集合（zSet）的其中一个实现，如果有序集合的元素大于128个或者集合中元素长度大于64，就会使用跳跃表，否则使用压缩列表。")]),s._v(" "),_("p",[s._v("**redis跳跃表的实现：**skipList + zskipListNode")]),s._v(" "),_("p",[_("img",{attrs:{src:"/images/redis/Redis%E8%B7%B3%E8%B7%83%E8%A1%A8.png",alt:"redis跳跃表.png"}})]),s._v(" "),_("p",[s._v("蓝色指skipList，右边部分是多个zskipListNode")]),s._v(" "),_("p",[s._v("skipList结构：")]),s._v(" "),_("ul",[_("li",[_("p",[s._v("header：指向第一个zskipListNode")])]),s._v(" "),_("li",[_("p",[s._v("tail：指向最后一个zskipListNode")])]),s._v(" "),_("li",[_("p",[s._v("level：当前跳跃表中层数最大的zskipListNode（头节点不算在内）")])]),s._v(" "),_("li",[_("p",[s._v("length：当前跳跃表的长度，即zskipListNode的数量（头节点不算在内）")])])]),s._v(" "),_("p",[s._v("zskiplistNode结构：")]),s._v(" "),_("ul",[_("li",[s._v("level：层，L1代表第一层，L2代表第二层。每一个level都有两个属性，一个是前进指针，一个是跨度。")]),s._v(" "),_("li",[s._v("backward（后退）：当前zskiplistNode的前一个节点")]),s._v(" "),_("li",[s._v("score：排序使用")]),s._v(" "),_("li",[s._v("对象：各节点保存的成员对象的指针，指向实际保存的地址。")])]),s._v(" "),_("h2",{attrs:{id:"三、线程模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、线程模型"}},[s._v("#")]),s._v(" 三、线程模型")]),s._v(" "),_("h3",{attrs:{id:"_1-文件事件处理器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-文件事件处理器"}},[s._v("#")]),s._v(" 1. "),_("strong",[s._v("文件事件处理器")])]),s._v(" "),_("p",[_("img",{attrs:{src:"/images/redis/%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png",alt:"文件事件处理器.png"}})]),s._v(" "),_("ul",[_("li",[_("p",[s._v("套接字（socket）")]),s._v(" "),_("p",[s._v("客户端连接、读写等操作请求，server socket根据这些请求产生文件事件，文件事件包括AE_READABLE，AE_WRITABLE，redis服务端可读，可连接产生的是AE_READABLE，可写产生的是AE_WRITABLE事件。")])]),s._v(" "),_("li",[_("p",[s._v("I/O多路复用程序")]),s._v(" "),_("p",[s._v("作用是用来监听server socket，并将这些socket顺序的放入队列中。")])]),s._v(" "),_("li",[_("p",[s._v("文件事件分派器")]),s._v(" "),_("p",[s._v("接收队列中的socket，并将socket中的文件事件类型与对应的事件处理器关联，根据对应的事件处理器进行操作。")])]),s._v(" "),_("li",[_("p",[s._v("事件处理器")]),s._v(" "),_("ul",[_("li",[s._v("连接应答处理器：redis服务器初始化时，关联服务器监听套接字产生的AE_READABLE事件。事件在客户端connect时产生，创建套接字。")]),s._v(" "),_("li",[s._v("命令请求处理器：客户端连接成功后，关联客户端套接字的AE_READABLE事件。")]),s._v(" "),_("li",[s._v("命令回复处理器：服务器有命令回复需要传送给客户端时，关联客户端套接字的AE_WRITABLE事件。事件在客户端尝试读取时产生。")])])])]),s._v(" "),_("p",[_("strong",[s._v("完整通信过程：")])]),s._v(" "),_("p",[_("img",{attrs:{src:"/images/redis/%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png",alt:"通信过程"}})]),s._v(" "),_("h3",{attrs:{id:"_2-时间事件处理器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-时间事件处理器"}},[s._v("#")]),s._v(" 2.时间事件处理器")]),s._v(" "),_("ul",[_("li",[s._v("刷新服务器信息")]),s._v(" "),_("li",[s._v("清理过期的key")]),s._v(" "),_("li",[s._v("持久化")])]),s._v(" "),_("p",[_("strong",[s._v("为什么说Redis是单线程实现的？")])]),s._v(" "),_("p",[s._v("-- redis内部使用文件事件处理器（file event handler），因为文件事件处理器在执行redis命令请求时是单线程执行的，而文件事件处理器是redis的核心，所以说redis是单线程的。")]),s._v(" "),_("p",[s._v("实际上redis从4.0版本开始，删除对象的操作也开始使用多线程处理。")]),s._v(" "),_("h2",{attrs:{id:"redis热key问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis热key问题"}},[s._v("#")]),s._v(" Redis热key问题")]),s._v(" "),_("h3",{attrs:{id:"一、什么是热key"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是热key"}},[s._v("#")]),s._v(" 一、什么是热key")]),s._v(" "),_("p",[s._v("瞬间有大量请求去访问redis上某个固定的key，导致redis服务器宕机。某些业务下如果redis服务不可用，则会请求数据库，导致数据库服务无法使用。")]),s._v(" "),_("h3",{attrs:{id:"二、如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、如何解决"}},[s._v("#")]),s._v(" 二、如何解决")]),s._v(" "),_("h4",{attrs:{id:"_1-监控"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-监控"}},[s._v("#")]),s._v(" 1. 监控")]),s._v(" "),_("ul",[_("li",[s._v("客户端收集：在调用redis服务的时候，增加一层监控，对所有rediskey进行ump监控。")]),s._v(" "),_("li",[s._v("redis服务集群代理：在redis服务器集群上做一层代理，所有请求经过这个代理，从而通过这个代理进行统一监控")]),s._v(" "),_("li",[s._v("redis自带命令：\n"),_("ul",[_("li",[s._v("monitor命令-可实时抓取redis服务器接收到的命令，需要单独开发统计的逻辑代码。")]),s._v(" "),_("li",[s._v("hotkeys参数-4.0.3版本以后加入，需要在客户端启动时增加-hotkeys参数。key比较多的情况下执行速度很慢。")])])])]),s._v(" "),_("h4",{attrs:{id:"_2-解决方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-解决方案"}},[s._v("#")]),s._v(" 2. 解决方案：")]),s._v(" "),_("p",[_("strong",[s._v("客户端缓存：")])]),s._v(" "),_("p",[s._v("redis服务器发现热key后，通过sdk把热key写入到客户端的本地缓存中，当key发生了写操作的时候，再把这个key从本地缓存中删除。")])])}),[],!1,null,null,null);_.default=e.exports}}]);