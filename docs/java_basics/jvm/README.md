# JVM

## JVM运行时数据区的组成

1. 程序计数器: 简单的说，线程计数器就是为了记录每个线程执行到哪一行的一块非常小的区域，所以说每个线程都有一个程序计数器为线程服务。 如果线程执行java方法，则程序计数器存放的是java方法的指令地址；如果执行本地的native方法，程序计数器为空。

2. 虚拟机栈: 线程私有的，虚拟机栈简称栈，是表示java方法执行的内存模型，每个java方法执行时都会创建一个栈帧，每个栈帧中存储了局部变量表、操作数栈、方法出口等信息，局部变量表在编译器就对其内存进行了分配。

    **异常情况**

    + 栈深度大于虚拟机允许的最大深度抛出StackOverflowError
    + 内存不足时抛出OutOfMemoryError

3. 本地方法栈: 与虚拟机栈类似，只是本地方法栈为本地方法服务。

4. 方法区: 所有线程共享，存储已经被虚拟机加载的类信息、常量、静态变量等数据

5. 堆: 所有线程共享，java内存中最大的一块区域，虚拟机启动时就被创建。堆内存中主要存放对象的实例和数据等信息。

**下图为jdk1.7之前的内存数据区划分**

![运行时数据区jdk7.jpeg](/images/java_basics/jvm/运行时数据区jdk7.jpeg)

**下图为jdk8以后的内存数据区结构**

![运行时数据区jdk8.jpeg](/images/java_basics/jvm/运行时数据区jdk8.jpeg)

## 栈帧中对象的引用方式

栈帧中的局部变量表存储的事对象的引用和一些基本的数据类型，但是栈帧中使用的对象实例则存储在堆内存中。局部变量表的对象引用一般有两种方式:

1. 使用句柄方式: 在堆内存中有一块区域作为句柄池，用来存放对象实例的指针和对象类型数据的指针，指向堆中的对象实例和方法区的对象类型数据。 这种方式的优点是比较灵活，在gc过程中，对象移动时只改变句柄池的对象指针即可。

![句柄方式.png](/images/java_basics/jvm/句柄方式.png)

2. 直接引用方式: 局部变量表的对象引用直接存储对象实例的指针，指向堆内存的对象实例，而对象类型数据则存在对象实例中。这种方式的优点是性能较句柄方式更好，节省了一次指针寻找地址的时间。

![直接引用方式.png](/images/java_basics/jvm/直接引用方式.png)

## 堆区

堆区分为新生代和老年代。而新生代则分为Eden区和survivor1以及survivor2

新创建的对象被存放在新生代，但是如果对象超大的话，会直接存放到老年代（需要设置jvm参数：-XX:PretenureSizeThreshold）。

![对象创建内存分配流程.png](/images/java_basics/jvm/对象创建内存分配流程.png)

## 虚拟机参数

|参数| 说明|
|--|--|
-Xmx -Xms|	堆内存的最大值和最小值，如果设置了最大和最小值，jvm启动后会开辟最小内存，经过数次GC后，还不能满足程序的运行需要，才会逐渐扩大内存.
-Xms | 默认为物理内存的1/64，最小为1M，-Xmx默认为物理内存的1/4或者1G，最小为2M，两者单位可自定义，若不置顶单位，默认为字节。|
-Xmn | 新生代的内存大小，官方推荐新生代占java堆的3/8|
-XX:NewSize|	设置年轻代大小|
-XX:MaxNewSize|	设置年轻代最大值|
-XX:NewRatio |	新生代和老年代的比例|
-XX:SurvivorRatio |	两个survivor区和eden区的比例|
-XX:PermSize -XX:MaxPermSize|	设置永久代的内存大小和最大值。MaxPermSize默认为物理内存的1/4|
-Xss|	栈的大小，默认1M|
-XXThreadStackSize|	设置线程栈的大小|
-XX:MaxTenuringThreshold|	设置垃圾的最大年龄，如果为0，则年轻代对象不会在eden区生成后不经过survivor区，直接进入老年代|
-XX:PretenureSizeThreshold|	设置对象超过多大时直接在老年代进行内存分配，默认为0|
-XX:+HeapDumpOnOutMemoryError|	发生OOM错误时，以文件形式导出堆信息。|
-XX:+HeapDumpPath|	OOM错误时导出的文件路径|
-XX:OnOutOfMemoryError|	当系统产生OOM时，执行一个指定的脚本，这个脚本可以是任意功能的。比如生成当前线程的dump文件，或者是发送邮件和重启系统。|
-XX:+UseSerialGC|	使用串行垃圾回收器|
-XX:+UseParNewGC|	使用PartNew垃圾回收器|
-XX:+UseConcMarkSweepGC|	使用CMS垃圾回收器，如果新生代没有配置垃圾回收器，会默认选择ParNew作为新生代的垃圾回收器|
-XX:ParallelGCThreads|	设置垃圾收集器的线程数量，不设置的情况下默认与CPU核心数一致|
-XX:MaxGCPauseMillis|	设置Parallel Scavenge垃圾收集器运行时业务线程停顿的最大时间（STW的时间）|
-XX:GCTimeRatio|	设置Parallel Scavenge垃圾收集器垃圾收集的时间占总时间的比例，该参数可以明确体现出CPU的吞吐量。|
-XX:+UseParallelOldGC|	指定老年代使用Parallel Old垃圾收集器|
-XX:+UseConcMarkSweepGC|	制定老年代使用CMS垃圾回收器|

## 垃圾回收

### 判断对象是否已死?

1. 引用计数法

对象会存一个引用计数器，每当有一个地方引用它，对象的计数器就+1，引用失效时，计数器-1；当计数器为0时，就代表对象不再被引用。

现在常用的JVM没有使用引用计数法，主要原因就是引用计数法无法解决对象的循环引用问题

2. 可达性分析算法（JVM使用的）

    **GC Roots对象：**
    - 虚拟机栈(栈桢中的本地变量表)中的引用的对象
    - 方法区中的类静态属性引用的对象
    - 方法区中的常量引用的对象
    - 本地方法栈中（native方法）的引用的对象

**可达性分析算法**：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，当一个对象到GC Roots没有任何引用链连接时，说明该对象已死。

### 垃圾回收算法

1. 标记-清除算法

分为标记和清除两个阶段，先标记出所有需要需要回收的对象，标记完成后统一回收所有被标记的对象。标记-清除算法的缺点：
+ 效率低
+ 产生较多的内存碎片，在系统需要分配大内存对象时可能会无法找到足够内存而出发另一次GC

![标记-清除算法.jpg](/images/java_basics/jvm/标记-清除算法.jpg)

2. 标记-整理算法(老年代回收算法)

与标记-清除算法前期方式一致，标记完需要回收的对象后，将存活对象移向另一端，这样存活的对象就时一整块连续的内存，将这些存活对象以外的直接批量清除即可。

![标记-整理算法.jpg](/images/java_basics/jvm/标记-整理算法.jpg)

3. 复制算法(新生代回收算法)

每次使用时只使用Eden和其中的一块Survivor区，回收时将Eden和Survivor1中还存活的对象一次性复制到Survivor2区，再将Eden和Survivor1区的对象清除。该算法的好处：
+ 简单高效（空间换时间）
+ 不会出现内存碎片，每次只操作一半区域

![复制算法.jpg](/images/java_basics/jvm/复制算法.jpg)

### 垃圾回收器
| 种类                     | GC方式 | 使用算法   | 适用区域         | 说明                                                                                                    |
| -------------------------- | ------ | -------------- | -------------------- | --------------------------------------------------------------------------------------------------------- |
| Serial                     | 串行 | 复制         | 新生代  | 执行时会SWT                                                                                           |
| Serial Old | 串行 | 标记-整理  | 老年代            | 执行时会SWT                                                                                           |
| ParNew                     | 并行 | 复制         | 新生代            | Serial的多线程版本，一般与老年代的CMS收集器公用，也会STW                            |
| Parallel Scavenge          | 并行 | 复制         | 新生代            | 关注点为CPU吞吐量，吞吐量的计算方式：CPU执行代码的时间/（执行代码时间+垃圾收集时间），执行垃圾收集时会SWT |
| Parallel Old               | 并行 | 标记-整理  | 老年代            | Parallel Scavenge的老年代版本，STW                                                                 |
| CMS(Concurrent Mark Sweep) | 并行 | 标记-清除  | 老年代            | STW时间较短，需要内存较大，由于使用标记-清除算法（不整理），会产生内存碎片 |
| G1(Garbage-First)          | 并行 | 标记-整理+复制 | 整个堆内存都可以使用 | 其他垃圾回收器度需要两种一起配合使用，G1可以单独使用。                          |

#### G1垃圾回收器

1. 特点

+ 其他垃圾回收器需要两种回收器一起配合使用，而单独使用G1回收器，就可以回收堆内存垃圾。
+ G1回收器将堆内存分为大小相同的独立区域（Region）
+ 虽然新生代和老年代的概念还保留，但是他们两个不再进行物理上的划分，而是存在不同的Region中，这些Region可以是不连续的。
+ G1回收器在执行时可以预估系统停止运行的时间：G1会根据收集出的每个Region中垃圾的大小生成一个列表，优先回收价值大的Region，这也是G1名字的由来。

2. 回收过程

    + 初始标记：只标记GC Root直接关联的对象，这个过程需要STW；
    + 并发标记：根据初始标记获得的存活对象继续向下查找标记（可达性分析），标记出所有存活的对象。这个阶段会与用户线程并行，虽然时间长，但是不会影响用户线程，缺点是不能标记出所有的对象，因为在这同时，用户线程会产生新的对象。
    + 最终标记：这时候需要STW，标记出并发标记过程中，用户线程继续运行而产生的新对象。
    + 并发清理：将所有Region的回收价值进行排序，按配置的停顿时间制定一个回收计划，根据回收计划进行回收。Region垃圾的回收使用复制算法，将一个Region中存活下来的对象复制到一个空的Region中，删除原来的Region。